[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sample Lecture Notes",
    "section": "",
    "text": "In Figure 1, we create an interactive 3D visualization of a surface plot, annotated with contour lines.\n\n\n\n\n\n\n\n\nFigure 1: Displaying \\(g(y,z)=e^{-z}\\sin(y)\\) as a surface plot annotated with contour lines."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Random R and Python Examples",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "index.html#interactive-visualizations-with-plotly",
    "href": "index.html#interactive-visualizations-with-plotly",
    "title": "Sample Lecture Notes",
    "section": "",
    "text": "In Figure 1, we create an interactive 3D visualization of a surface plot, annotated with contour lines.\n\n\n\n\n\n\n\n\nFigure 1: Displaying \\(g(y,z)=e^{-z}\\sin(y)\\) as a surface plot annotated with contour lines."
  },
  {
    "objectID": "index.html#the-euler-methods-and-variants",
    "href": "index.html#the-euler-methods-and-variants",
    "title": "Sample Lecture Notes",
    "section": "The Euler Methods and Variants",
    "text": "The Euler Methods and Variants"
  },
  {
    "objectID": "index.html#the-explicit-euler-method",
    "href": "index.html#the-explicit-euler-method",
    "title": "Sample Lecture Notes",
    "section": "The Explicit Euler Method",
    "text": "The Explicit Euler Method\nThe Explicit Euler Method is also known as the forward Euler Method.\nConsider the general form of an explicitly defined first order ODE:\n\\[\\frac{dS(t)}{dt} = F(t,S(t))\\]\nThat is, \\(F\\) is a function that returns the derivative of a state given a time and state value.\nLet \\(t\\) be a numerical grid of the interval \\([t_0, t_f]\\) with spacing \\(h\\). Without loss of generality, we assume that \\(t_0 = 0\\), and that \\(t_f = Nh\\) for some positive integer, \\(N\\).\nThe linear approximation (tangent line) of \\(S(t)\\) around \\(t_j\\) at \\(t_{j+1}\\) is\n\\[S(t_{j+1}) = S(t_j) + (t_{j+1} - t_j)S'(t_j),\\]\nwhich can also be written as:\n\\[S(t_{j+1}) = S(t_j) + hF(t_j, S(t_j)). \\quad \\text{Explicit Euler Formula} \\tag{1}\\]\nEquation Equation 1 is called the Explicit Euler Formula, and it allows us to compute an approximation for the state at \\(S(t_{j+1})\\) given the state at \\(S(t_j)\\). Starting from a given initial value of \\(S_0 = S(t_0)\\), we can use this formula to integrate the states up to \\(S(t_f)\\); these \\(S(t)\\) values are then an approximation for the solution of the differential equation. The Explicit Euler formula is the simplest and most intuitive method for solving initial value problems. At any state \\((t_j, S(t_j))\\) it uses \\(F\\) at that state to “point” toward the next state and then moves in that direction a distance of \\(h\\). See Figure 2.\nAlthough there are more sophisticated and accurate methods for solving these problems, they all have the same fundamental structure. As such, we enumerate explicitly the steps for solving an initial value problem using the Explicit Euler formula.\n\n\n\n\n\n\nFigure 2: The illustration of the explicit Euler method.\n\n\n\n\nAdd a reference by DOI: https://doi.org/10.1142/12031\n\nReference: (Lambers, Mooney, and Montiforte 2020)\nWHAT IS HAPPENING? Assume we are given a function \\(F(t, S(t))\\) that computes \\(\\frac{dS(t)}{dt}\\), a numerical grid, \\(t\\), of the interval, \\([t_0, t_f]\\), and an initial state value \\(S_0 = S(t_0)\\). We can compute \\(S(t_j)\\) for every \\(t_j\\) in \\(t\\) using the following steps.\n\nStore \\(S_0 = S(t_0)\\) in an array, \\(S\\).\nCompute \\(S(t_1) = S_0 + hF(t_0, S_0)\\).\nStore \\(S_1 = S(t_1)\\) in \\(S\\).\nCompute \\(S(t_2) = S_1 + hF(t_1, S_1)\\).\nStore \\(S_2 = S(t_1)\\) in \\(S\\).\n\\(\\cdots\\)\nCompute \\(S(t_f) = S_{f-1} + hF(t_{f-1}, S_{f-1})\\).\nStore \\(S_f = S(t_f)\\) in \\(S\\).\n\\(S\\) is an approximation of the solution to the initial value problem.\n\nWhen using a method with this structure, we say the method integrates the solution of the ODE.\n\nExample 1 The differential equation\n\\[\\frac{df(t)}{dt} = e^{-t}\\]\nwith initial condition \\(f_0 = -1\\) has the exact solution \\(f(t) = -e^{-t}\\). Approximate the solution to this initial value problem between 0 and 1 in increments of 0.1 using the Explicit Euler Formula. Plot the difference between the approximated solution and the exact solution.\n\n\nSolution. \n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define functions\nf_exact = lambda t: -np.exp(-t) # Exact Solution\nF = lambda t, f: np.exp(-t)  # F(t,f) = df(t)/dt\nh = 0.1 # Step size\nt = np.arange(0, 1 + h, h) # Numerical grid\nf0 = -1 # Initial Condition of f(t)\n\n# Explicit Euler Method\nf = np.zeros(len(t))\nf[0] = f0\n\nfor i in range(0, len(t) - 1):\n  f[i + 1] = f[i] + h*F(t[i], f[i])\n\nplt.figure(figsize = (8, 6))\nplt.plot(t, f, 'bo--', label='Approximate')\nplt.plot(t, f_exact(t), 'g', label='Exact')\nplt.title('Approximate and Exact Solution for Simple ODE')\nplt.xlabel('t')\nplt.ylabel('f(t)')\nplt.grid()\nplt.legend(loc='lower right')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nIn the above figure, we can see each dot is one approximation based on the previous dot in a linear fashion. From the initial value, we can eventually get an approximation of the solution on the numerical grid. If we repeat the process for \\(h = 0.01\\), we get a better approximation for the solution:\n\n\nCode\nh = 0.01 # Step size\nt = np.arange(0, 1 + h, h) # Numerical grid\nf0 = -1 # Initial Condition\n\n# Explicit Euler Method\nf = np.zeros(len(t))\nf[0] = f0\n\nfor i in range(0, len(t) - 1):\n  f[i + 1] = f[i] + h*F(t[i], f[i])\n\nplt.figure(figsize = (8, 6))\nplt.plot(t, f, 'b--', label='Approximate')\nplt.plot(t, -np.exp(-t), 'g', label='Exact')\nplt.title('Approximate and Exact Solution for Simple ODE')\nplt.xlabel('t')\nplt.ylabel('f(t)')\nplt.grid()\nplt.legend(loc='lower right')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExercise 1 Solve numerically the IVP using the Explicit Euler Method over the interval \\([0,1]\\):\n\\[\\frac{dy}{dt}=ty+t^3, \\, y(0)=1\\]\nThe exact solution can be obtained using the methods for solving ODEs, and it is the following function:\n\\[y(t)=3e^{t^2/2}-t^2-2\\]\nCompare the exact and approximate solutions by plotting them on the same plot over \\([0,1]\\).\n\n\nSolution. \n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# exact solution \ndef sol(t):\n    return 3 * np.exp(t**2 / 2) - t**2 - 2\n\n# Function for the right-hand side of the ODE\ndef f(t, y):\n    return t * y + t**3\n\n# Step size\nh = 0.01\n\n# Discretization of the independent variable t\nt = np.arange(0, 1 + h, h)  # Including endpoint\n\n# Initialize the discrete solution vector\ny = np.zeros(len(t))\ny[0] = 1  # Set initial condition (note Python's 0-based indexing)\n\n# Implementing the Explicit Euler Method\nfor k in range(1, len(t)):\n    y[k] = y[k - 1] + h * f(t[k - 1], y[k - 1])\n\n# Plotting the theoretical solution\nplt.figure(figsize=(8, 6))\nplt.plot(t, sol(t), label='Exact Solution', color='blue', linewidth=3)\n\n# Plotting the numerical solution\nplt.scatter(t, y, color='red', s=20, label='Numerical Solution (Euler Method)')  # using scatter for points\nplt.title(\"Solution of Differential Equation\")\nplt.xlabel(\"t\")\nplt.ylabel(\"y\")\nplt.grid()\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nFunction sol: This function is the exact solution of this IVP.\nFunction f: Represents the right-hand side of the differential equation dy/dt = t * y + t^3.\nStep size and discretization: The R code defines a step size h and creates a sequence of time points t from 0 to 1 with step size h.\nInitialization of solution vector: An array y is initialized to store the solution, with the initial condition y[0] set to 1.\nExplicit Euler Method: A for loop updates the solution vector y using the explicit Euler formula.\nPlotting results and adding grid: The numerical solution is plotted and a grid is added for better visualization."
  },
  {
    "objectID": "index.html#the-implicit-euler-method",
    "href": "index.html#the-implicit-euler-method",
    "title": "Sample Lecture Notes",
    "section": "The Implicit Euler Method",
    "text": "The Implicit Euler Method\nThe Explicit Euler Formula is called “explicit” because it only requires information at \\(t_j\\) to compute the state at \\(t_{j+1}\\). That is, \\(S(t_{j+1})\\) can be written explicitly in terms of values we have (i.e., \\(t_j\\) and \\(S(t_j)\\)). The Implicit Euler Formula can be derived by taking the linear approximation of \\(S(t)\\) around \\(t_{j+1}\\) and computing it at \\(t_j\\):\n\\[\nS(t_{j+1}) = S(t_j) + hF(t_{j+1}, S(t_{j+1})). \\quad \\text{(Implicit Euler Formula)}\n\\]\nThis formula is peculiar because it requires that we know \\(S(t_{j+1})\\) to compute \\(S(t_{j+1})\\)! However, it happens that sometimes we can use this formula to approximate the solution to initial value problems. The Implicit Euler Method is also known as the backward Euler Method. It is a numerical method for solving ordinary differential equations (ODEs).\nHere’s a simple example of how to solve an initial value problem (IVP) using the Implicit Euler Method.\n\nExercise 2 Consider the differential equation:\n\\[\\frac{dy}{dt} = -3y\\] with the initial condition \\(y(0) = 1\\).\n\n\nSolution. This is a simple linear ODE where the exact solution is \\(y(t) = e^{-3t}\\). We’ll use the Implicit Euler Method to approximate the solution over the interval \\(t \\in [0, 1]\\) with a step size \\(h\\).\nImplicit Euler Formula\nThe Implicit Euler update formula is:\n\\[y_{n+1} = y_n + h \\cdot f(t_{n+1}, y_{n+1})\\]\nFor our specific equation \\(\\frac{dy}{dt} = -3y\\), it becomes:\n\\[y_{n+1} = y_n - 3h \\cdot y_{n+1}\\]\nRearranging to solve for \\(y_{n+1}\\):\n\\[y_{n+1} + 3h \\cdot y_{n+1} = y_n\\]\n\\[y_{n+1} (1 + 3h) = y_n\\]\n\\[y_{n+1} = \\frac{y_n}{1 + 3h}\\]\nPython Implementation\nLet’s calculate the solution with a step size \\(h = 0.1\\) over the interval from 0 to 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nh = 0.1\nt_end = 1\ny0 = 1\n\n# Time steps using np.arange\nt = np.arange(0, t_end + h, h)  # Include t_end by adding h\n\n# Initialize the array for y\ny = np.zeros(len(t))\ny[0] = y0\n\n# Implicit Euler method\nfor n in range(len(t) - 1):\n    y[n + 1] = y[n] / (1 + 3 * h)\n\n# Exact solution for comparison\ny_exact = np.exp(-3 * t)\n\n# Plotting\nplt.figure(figsize=(8, 6))\nplt.plot(t, y, 'o-', label='Implicit Euler Approximation')\nplt.plot(t, y_exact, 'k--', label='Exact Solution')\nplt.title('Solution of dy/dt = -3y using Implicit Euler Method')\nplt.xlabel('Time t')\nplt.ylabel('y(t)')\nplt.legend()\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "index.html#trapezoidal-euler-formula",
    "href": "index.html#trapezoidal-euler-formula",
    "title": "Sample Lecture Notes",
    "section": "Trapezoidal Euler Formula",
    "text": "Trapezoidal Euler Formula\nThe Trapezoidal Euler Formula is the average of the Explicit and Implicit Euler Formulas:\n\\[\nS(t_{j+1}) = S(t_j) + \\frac{h}{2}(F(t_j, S(t_j)) + F(t_{j+1}, S(t_{j+1}))). \\quad \\text{(Trapezoidal Formula)}\n\\]\nThe Euler Trapezoidal Formula, also known as the Trapezoidal Rule or Heun’s Method, is another approach for numerically solving ordinary differential equations (ODEs). This method can be thought of as a predictor-corrector scheme where an initial prediction using the forward Euler method is corrected by averaging the function values at the beginning and end of the interval.\nFor the same example as before:\n\\[\\frac{dy}{dt} = -3y\\]\nwith the initial condition \\(y(0) = 1\\), let’s implement the solution using the Trapezoidal Rule over the interval \\(t \\in [0, 1]\\) with a step size \\(h = 0.1\\).\nTrapezoidal Rule Formula\nThe trapezoidal update formula is:\n\\[y_{n+1} = y_n + \\frac{h}{2} \\left( f(t_n, y_n) + f(t_{n+1}, y_{n+1}^{pred}) \\right)\\]\nwhere \\(y_{n+1}^{pred}\\) is the prediction from the forward Euler method:\n\\[y_{n+1}^{pred} = y_n + h \\cdot f(t_n, y_n)\\]\nFor the ODE \\(\\frac{dy}{dt} = -3y\\), the formula becomes:\n\\[y_{n+1} = y_n + \\frac{h}{2} \\left( - 3y_n - 3y_{n+1}^{pred} \\right)\\]\n\\[y_{n+1} = y_n - \\frac{3h}{2} \\left( y_n + y_{n+1}^{pred} \\right)\\]\n\\[y_{n+1}^{pred} = y_n - 3h y_n\\]\n\\[y_{n+1} = y_n - \\frac{3h}{2} \\left( y_n + y_n - 3h y_n \\right)\\]\nImplementation in Python\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parameters\nh = 0.1\nt_end = 1\ny0 = 1\n\n# Time steps\nt = np.arange(0, t_end + h, h)\n\n# Initialize the array for y\ny = np.zeros(len(t))\ny[0] = y0\n\n# Trapezoidal Rule method\nfor n in range(len(t) - 1):\n    y_pred = y[n] - 3 * h * y[n]  # Predictor step\n    y[n + 1] = y[n] - 1.5 * h * (y[n] + y_pred)  # Corrector step\n\n# Exact solution for comparison\ny_exact = np.exp(-3 * t)\n\n# Plotting\nplt.figure(figsize=(8, 6))\nplt.plot(t, y, 'o-', label='Trapezoidal Rule Approximation')\nplt.plot(t, y_exact, 'k--', label='Exact Solution')\nplt.title('Solution of dy/dt = -3y using Trapezoidal Rule')\nplt.xlabel('Time t')\nplt.ylabel('y(t)')\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nExplanation:\n\nPredictor Step: Using the forward Euler method, we predict \\(y_{n+1}\\).\nCorrector Step: We then use the average of the derivatives at \\(t_n\\) and \\(t_{n+1}\\) based on the prediction to correct \\(y_{n+1}\\).\nPlotting: This plots both the numerical solution using the Trapezoidal Rule and the exact solution, showing how closely the numerical method approximates the true solution.\n\nThis approach is generally more accurate than the basic Euler methods and is particularly useful for problems where higher numerical stability is desired."
  },
  {
    "objectID": "index.html#python-ode-solvers",
    "href": "index.html#python-ode-solvers",
    "title": "Sample Lecture Notes",
    "section": "Python ODE Solvers",
    "text": "Python ODE Solvers\nIn scipy, there are several built-in functions for solving initial value problems. The most common one used is the scipy.integrate.solve_ivp function. The function construction are shown below:\nCONSTRUCTION:\nLet \\(F\\) be a function object to the function that computes\n\\[\\frac{dS(t)}{dt} = F(t, S(t)), \\quad S(t_0)=S_0\\] Here \\(t\\) is a one-dimensional independent variable (time), \\(S(t)\\) is an n-dimensional vector-valued function (state), and the \\(F(t, S(t))\\) defines the differential equations. \\(S_0\\) be an initial value for \\(S\\). The function \\(F\\) must have the form \\(F(t, S)\\), although the name does not have to be \\(F\\). The goal is to find the \\(S(t)\\) approximately satisfying the differential equations, given the initial value \\(S(t_0)=S_0\\).\nThe way we use the solver to solve the differential equation is:\nsolve_ivp(fun, t_span, s0, method = 'RK45', t_eval=None)\nwhere \\(fun\\) takes in the function in the right-hand side of the system. \\(t\\_span\\) is the interval of integration \\((t0, tf)\\), where \\(t0\\) is the start and \\(tf\\) is the end of the interval. \\(s0\\) is the initial state. There are a couple of methods that we can choose, the default is ‘RK45’, which is the explicit Runge-Kutta method of order 5(4). There are other methods you can use as well, see the end of this section for more information. \\(t\\_eval\\) takes in the times at which to store the computed solution, and must be sorted and lie within \\(t\\_span\\).\nLet’s try one example below.\n\nExample 2 Consider the ODE\n\\[\n\\frac{dS(t)}{dt}=\\cos(t)\n\\]\nfor an initial value \\(S_0 = 0\\). The exact solution to this problem is \\(S(t) = \\sin(t)\\). Use solve_ivp to approximate the solution to this initial value problem over the interval \\([0, \\pi]\\). Plot the approximate solution versus the exact solution and the relative error over time.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\nF = lambda t, s: np.cos(t)\n\nt_eval = np.arange(0, np.pi, 0.1)\nsol = solve_ivp(F, [0, np.pi], [0], t_eval=t_eval)\n\nplt.figure(figsize = (9, 4))\nplt.subplot(121)\nplt.plot(sol.t, sol.y[0])\nplt.xlabel('t')\nplt.ylabel('S(t)')\nplt.subplot(122)\nplt.plot(sol.t, sol.y[0] - np.sin(sol.t))\nplt.xlabel('t')\nplt.ylabel('S(t) - sin(t)')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThe above left figure shows the integration of \\(\\frac{dS(t)}{dt}=\\cos(t)\\) with solve_ivp. The right figure computes the difference between the solution of the integration by solve_ivp and the evalution of the analytical solution to this ODE. As can be seen from the figure, the difference between the approximate and exact solution to this ODE is small. Also, we can control the relative and absolute tolerances using the rtol and atol arguments, the solver keeps the local error estimates less than \\(atol + rtol*abs(S)\\). The default values are 1e-3 for rtol and 1e-6 for atol.\nTRY IT! Using the rtol and atol to make the difference between the approximate and exact solution is less than 1e-7.\n\n\nCode\nsol = solve_ivp(F, [0, np.pi], [0], t_eval=t_eval, rtol = 1e-8, atol = 1e-8)\n\nplt.figure(figsize = (9, 4))\nplt.subplot(121)\nplt.plot(sol.t, sol.y[0])\nplt.xlabel('t')\nplt.ylabel('S(t)')\nplt.subplot(122)\nplt.plot(sol.t, sol.y[0] - np.sin(sol.t))\nplt.xlabel('t')\nplt.ylabel('S(t) - sin(t)')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nExample 3 Consider the ODE\n\\[\n\\frac{dS(t)}{dt} = -S(t),\n\\]\nwith an initial value of \\(S_0 = 1\\). The exact solution to this problem is \\(S(t) = e^{-t}\\). Use solve_ivp to approximate the solution to this initial value problem over the interval \\([0, 1]\\). Plot the approximate solution versus the exact solution, and the relative error over time.\n\n\nCode\nF = lambda t, s: -s\n\nt_eval = np.arange(0, 1.01, 0.01)\nsol = solve_ivp(F, [0, 1], [1], t_eval=t_eval)\n\nplt.figure(figsize = (9, 4))\nplt.subplot(121)\nplt.plot(sol.t, sol.y[0])\nplt.xlabel('t')\nplt.ylabel('S(t)')\nplt.subplot(122)\nplt.plot(sol.t, sol.y[0] - np.exp(-sol.t))\nplt.xlabel('t')\nplt.ylabel('S(t) - exp(-t)')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nThe above figure shows the corresponding numerical results. As in the previous example, the difference between the result of solve_ivp and the evaluation of the analytical solution by Python is very small in comparison to the value of the function."
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Course Syllabus",
    "section": "",
    "text": "Lecture\nTopic\nHomework\n\n\n\n\n1\nIntroduction\n1.1. 1.2\n\n\n2\nWhat is Probability?\n\n\n\n3\nWhat is Bayesian Modeling?\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6"
  },
  {
    "objectID": "syllabus.html#lecture-schedule",
    "href": "syllabus.html#lecture-schedule",
    "title": "Course Syllabus",
    "section": "",
    "text": "Lecture\nTopic\nHomework\n\n\n\n\n1\nIntroduction\n1.1. 1.2\n\n\n2\nWhat is Probability?\n\n\n\n3\nWhat is Bayesian Modeling?\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6"
  },
  {
    "objectID": "about.html#r-rxample",
    "href": "about.html#r-rxample",
    "title": "Random R and Python examples",
    "section": "",
    "text": "sample&lt;-rnorm(1e6)\nhist(sample, 100)"
  },
  {
    "objectID": "about.html#python-example",
    "href": "about.html#python-example",
    "title": "Random R and Python Examples",
    "section": "Python Example",
    "text": "Python Example\n\n[x**2 for x in range(1,6)]\n\n[1, 4, 9, 16, 25]"
  },
  {
    "objectID": "about.html#r-example",
    "href": "about.html#r-example",
    "title": "Random R and Python Examples",
    "section": "R Example",
    "text": "R Example\n\nsample&lt;-rnorm(1e6)\nhist(sample, 100)"
  }
]